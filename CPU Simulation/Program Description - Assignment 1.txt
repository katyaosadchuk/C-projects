Program DescriptionKateryna OsadchukAssignment 1      I split my program into 3 files: the main program, the FIFO queue structure, and the priority queue structure.  The FIFO queue and priority queue are nearly identical in format and their only differences are the details for the functions. For this reason, I will address the design choices made for those two files together.       Both queue files contain two functions (add/remove) and the corresponding header files contain a struct that is used as the nodes of the queue. The struct for the FIFO queue, called “Node 1”, stores the job number, the arrival time, and a pointer to the next node in the queue. The arrival time variable stores the time when the job arrives to the queue and is used to calculate the total response rate for the job at the given server.  For the priority queue, I created a struct called “Node 2” that stores the job number, the type of job, the time of the event (this is the priority of the job), and a pointer to the next node in the queue. I made two main design choices for the queues. First, when I remove a node from either queue, I extract the node’s contents into a new node that will be returned. The reason I return a node is because I need to see not only the job number that is being popped off the queue, but also the timestamp and job type (for priority queue) or the arrival time (FIFO queue). If I were not tracking the response time, it would have been possible to return just a job number when removing from the FIFO queue. Another design choice I made is when adding to either queue, I first check if the queue is empty. This is done in lines 14 of fifo.c and 17 of priority_queue.c. You’ll notice that I use two conditions to check if the queue is empty: head == NULL and (*head)->jobNumber == 0. While the former is self-explanatory, the latter expression is also important to test if the queue is empty. This is because when the node is declared outside of a function, its int variables are initialized to 0 by the compiler. Since jobNumber starts at 1 and is strictly increasing, we can see if the node is empty by testing if jobNumber is set to 0 (source: https://stackoverflow.com/questions/29336359/how-do-you-check-if-a-struct-is-initialized-in-c). I noticed that when I didn’t include (*head)->jobNumber == 0 as a condition for testing for an empty queue, I ran into issues when I ran my program since the add method was trying to traverse an empty queue. Perhaps there are better ways to check if the queue is empty, but this approach worked well for me.      Now, the main method had many more design choices and its layout is a bit more complicated. First, I will summarize the contents of the file:
lines 11-68: Global variables lines 72-77: Function prototypeslines 80-148: Main methodlines 151-192: Function to print program statistics to a filelines 195-232: Function to extract config.txt informationlines 236-271: Function to process a job arrivinglines 275-370: Function to process job finishing on CPUlines 373-428: Function to process job finishing on D1lines 431-485: Function to process job finishing on D2While there are an absurd amount of global variables, most of them are used as counters for gathering statistics (such as throughput for each server, etc). Another set of global variables is the config variables, since they are accessed by multiple functions. I initialized these to some default values so that if the config.txt file is not found, the program can still run. Next, I have a Boolean for each server indicating if it is busy or not. I used a Boolean because it improves readability since reading “CPU_Busy = true” is more explanatory than “CPU_Busy = 1”, (using an int to keep track of the state is another, though more confusing, option).  I also include some counters that track the current time, as well as the current number of jobs in each queue. These counters help the program run smoothly and keep track of the current state of the queues. Finally, I made the file pointer for the log file global so that I can log when a job exits, since that is done in a function outside main. 	In my main program, I open a log.txt file for writing, call the function that extracts the config values from config.txt, allocate memory for each queue, and then run a loop until FIN_TIME. In the loop, I pop an element from the priority queue, call the function handler that corresponds with its job type, and then print a status to the log. When the loop finishes, I call the function that calculates and prints the statistics to a file. While I omitted a simulation_ends function, I check that the job I popped off the priority queue has a timestamp less than FIN_TIME. If the timestamp is above FIN_TIME, I end the simulation. 	Perhaps the most design choices were made in how I gather the statistics. As mentioned, I keep a number of counters and then use the values I gathered to compute the required stats. To calculate throughput, I keep track of how many jobs each server completes, and then use the formula t=(number of jobs)/(FINTIME-INITTIME). I also keep track of how many jobs are on each queue. When a new job is added to a particular queue, I update the variable that keeps track of the queue’s size and check if the new size is bigger than the maximum size I have stored. If it is, I update the maximum size to the current size. This allows me to easily find the maximum queue size for each server. To compute the average queue size, I keep a running sum of the queue lengths and a sum of how many times the queue's size changed. I then use the formula avg=(sum of all queue lengths)/(number of times length changed+1) to find the average size. This is a bit confusing so suppose a queue starts with 3 jobs. Then I add 2 jobs to the queue so its new length is 5. The sum is now 3 + 5=8 and the length changed once so avg=8/(1+1)=4. This makes sense since the average between 3 and 5 is 4. This is exactly the approach I use to compute the average queue length. Then, I also keep track of how long each server is busy by keeping a running sum to which I add the time a job occupies on the server. Finally, I compute the response time for each job using the formula r=currentTime-arrivalTime+time_on_server. Recall that arrivalTime is the time the job arrives at the queue, so currentTime – arrivalTime gives us the total time the job spent in the queue. Finally the response time is the time the job was waiting in the queue plus the time it spent on the server. Once I calculate the response time of a job, I use that value to find the max and average response time for the server basically exactly as I had for the queue sizes. While the way I calculated the statistics involves a lot of bookkeeping, counters, and formulas, I found this way easier than parsing a log file, which is another option. The reason I chose this approach instead of parsing a log file is because I find parsing strings and files in C very tedious and annoying. 	Another design choice I made in the main method was how I parsed the config file. I read the file line by line and used sscanf to find and extract the first number in the given line. I saved the extracted number to an array. Since I used this approach, I had to change the field names DISK1_MIN/DISK1_MAX to DISK_ONE_MIN/DISK_ONE_MAX (and similarly for disk 2) or else I would be extracting the wrong number. Note that since I was using sscanf to extract the values, I had to handle the exit probability separately since it was the only field that wasn’t an integer. A very important note I should make is that due to how I parse the config file, it must be written in the following order:

SEED
INIT_TIME
FIN_TIME
ARRIVE_MIN
ARRIVE_MAX
CPU_MIN
CPU_MAX
DISK_ONE_MIN
DISK_ONE_MAX
DISK_TWO_MIN
DISK_TWO_MAX
QUIT_PROB

Otherwise, the values will not be extracted correctly. I know this is an inconvenience, but since I had finite time to write this lab, I had to make some sacrifices. There are numerous other ways to parse the file, but this was the simplest solution I could think of.	Apart from these choices, everything else was fairly straightforward and didn’t leave much room for interpretation. I tested my program in a few ways. First, I tested the FIFO and priority queue individually after I built them by creating and manipulating queues. Once I saw that they were working correctly, I moved onto building the main program. Then, once I was done building the program, I made sure everything worked correctly by changing the values on the config.txt file and making sure that the statistics were relatively stable. I also ran the program multiple times for a given configuration to make sure the results were reproducible.  

